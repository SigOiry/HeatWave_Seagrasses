---
title: Draft -- Effect of Atmospheric Heatwaves on Reflectance and Pigment Composition of Intertidal *Nanozostera noltei*  -- Draft
author:
  - name: Simon Oiry
    orcid: 0000-0001-7161-5246
    corresponding: true
    email: oirysimon@gmail.com
    roles:
      - Investigation
      - Writing
      - Data acquisition
    affiliations:
      - Institut des Substances et Organismes de la Mer, ISOMer, Nantes Université, UR 2160, F-44000 Nantes, France
  - name: Bede Ffinian Rowe Davies
    corresponding: false
    roles: 
      - Investigation
      - Data acquisition
      - Revision
    affiliations:
      - Institut des Substances et Organismes de la Mer, ISOMer, Nantes Université, UR 2160, F-44000 Nantes, France
  - name: Philippe Rosa
    corresponding: false
    roles: 
      - Data acquisition
      - Revision
    affiliations:
      - Institut des Substances et Organismes de la Mer, ISOMer, Nantes Université, UR 2160, F-44000 Nantes, France
  - name: Augustin Debly
    corresponding: false
    roles: 
      - Investigation
      - Data acquisition
      - Revision
    affiliations:
      - Institut des Substances et Organismes de la Mer, ISOMer, Nantes Université, UR 2160, F-44000 Nantes, France
  - name: Anne-Laure Barillé
    corresponding: false
    roles: 
      - Investigation
      - Data acquisition
      - Revision
    affiliations:
      - Bio-littoral, Immeuble Le Nevada, 2 Rue du Château de l'Eraudière, 44300 Nantes, France
  - name: Nicolas Harrin
    corresponding: false
    roles: 
      - Investigation
      - Data acquisition
      - Revision
    affiliations:
      - Bio-littoral, Immeuble Le Nevada, 2 Rue du Château de l'Eraudière, 44300 Nantes, France
  - name: Pierre Gernez
    corresponding: false
    roles: 
      - Investigation
      - Data acquisition
      - Revision
    affiliations:
      - Institut des Substances et Organismes de la Mer, ISOMer, Nantes Université, UR 2160, F-44000 Nantes, France
  - name: Laurent Barillé
    corresponding: false
    roles: 
      - Investigation
      - Data acquisition
      - Revision
    affiliations:
      - Institut des Substances et Organismes de la Mer, ISOMer, Nantes Université, UR 2160, F-44000 Nantes, France
keywords:
  - Remote Sensing
  - Pigment Composition
  - Seagrass
  - Coastal Ecosystems
  - Heatwaves 
abstract: |
  To be written
plain-language-summary: |
  To be written
key-points:
  - An intertidal vegetation classifier has been built to be used across different study sites without losing classification accuracy. 
  - Neural Network made to accuratly discriminates intertidal seagrasses from green algae (chlorophyceae)
date: last-modified
citation:
  container-title: Remote Sensing of Environment
number-sections: true
notebook-links: false
editor_options: 
  chunk_output_type: console
csl: RSE.csl
---

```{r library}
#| cache: true
#| echo: false
#| eval: true
#| warning: false

library(tidyverse)
```

# Introduction

Intertidal seagrasses play a crucial role in the ecosystem by providing habitats and feeding grounds for various marine species, supporting rich marine biodiversity, and contributing significantly to primary production and carbon sequestration [@unsworth2022planetary ; @sousa2019blue]. These seagrasses are essential in maintaining the health of coastal ecosystems by stabilizing sediments, filtering water, and serving as indicators of environmental changes due to their sensitivity to water quality variations [@zoffoli2021decadal]. The interactions between seagrass meadows and their associated herbivores further enhance the delivery of ecosystem services, including coastal protection and fisheries support [@jankowska2019stabilizing ; @zoffoli2023remote ; @gardner2018global]. Understanding and preserving these ecosystems are vital for maintaining the biodiversity and productivity of coastal regions [@scott2018role ; @ramesh2020seagrass].

Despite their crucial role in marine ecosystems, intertidal seagrasses face numerous threats that compromise their health and functionality. Coastal development and human activities are primary threats. These activities not only reduce the available habitat for seagrasses but also increase water turbidity, which limits light penetration and hampers photosynthesis [@waycott2009accelerating]. Seagrasses are also threatened by nutrient enrichment from agricultural and urban runoff, which can lead to eutrophication. This condition promotes the overgrowth of algal blooms that compete with seagrasses for light and nutrients, further stressing these important plants [@thomsen2023meadow] (Oiry et al. 2024). Pollution from industrial and agricultural fields sources introduces harmful chemicals and heavy metals into coastal waters, posing toxic risks to seagrass health. These pollutants can affect the physiological processes of seagrasses, reducing their growth and survival rates [@sevgi2022bitkilerde] Additionally, invasive species can out compete native seagrasses for resources, altering community structure and function [@simpson2016distribution].

Heatwaves, exacerbated by climate change, pose a growing threat to seagrasses. Marine Heatwaves (MHW), defined by @hobday2016hierarchical as prolonged discrete anomalously warm water events, and Atmospheric Heatwaves (AHW), defined by @perkins2013measurement as periods of at least three consecutive days with temperatures exceeding the 90th percentile, cause severe physiological stress on seagrasses [@sawall2021chronically; @deguette2022physiological]. At the interface between the land and oceans, intertidal seagrasses are exposed to both MHW and AHW. Heatwaves have profound impacts on seagrasses, with their effects varying based on species and geographic location. For instance, the seagrass *Zostera marina* exhibits high susceptibility to elevated sea surface temperatures during winter and spring, leading to advanced flowering, high mortality rates, and reduced biomass [@sawall2021chronically]. Similarly, *Cymodocea nodosa* shows increased photosynthetic activity during heatwaves but suffers negative effects on photosynthetic performance and leaf biomass during recovery [@deguette2022physiological]. Additionally, different populations of *Zostera marina* along the European thermal gradient exhibit varied photophysiological responses during the recovery phase of heatwaves, indicating differential adaptation capabilities among populations [@winters2011effects]. These events intensify other stressors, such as overgrazing and seed burial, compromising sexual recruitment [@guerrero2020heat].

Bleaching and darkening events of seagrass beds have been observed following episodes of intense heat along the Brittany coast of France (Pers. obs.) then affecting leaf color, which are expected to alter leaf reflectance. Remote sensing is increasingly being utilized to monitor marine ecosystems, including seagrass meadows. By using spectral indices, such as the Normalized Difference Vegetation Index (NDVI) and the Soil-Adjusted Vegetation Index (SAVI), or by analyzing specific spectral patterns, remote sensing can effectively quantify vegetation health over time [@huete2012vegetation ; @kloos2021agricultural ; @carlan2020identifying ; @akbar2020mangrove]. Through the Water Framework Directive and the Marine Strategy Framework Directive, Europe is promoting remote sensing techniques for habitat mapping, as these methods enable the monitoring of extensive areas over time [@papathanasopoulou2019satellite]. This study will experimentally test the hypothesis that warm events modify the pigment composition and reflectance of seagrass, linking these changes with satellite remote sensing.

# Material & Methods

## Observation of an *in situ* heatwave event over a seagrass meadow.

### FieldTrip

```{r filedtrip Quadrats}
#| cache: true
#| echo: false
#| eval: false
#| warning: false

library(tidyverse)
library(exiftoolr)
library(shiny)

image_list <- list.files("Data/Biolittoral/Bio-Littoral_Drone/OFB2021_Quadrat_Zost_QBR", recursive = T, full.names = T) %>% 
  as_tibble() %>% 
  dplyr::rename(path = "value") %>% 
  dplyr::mutate(filename = gsub(".*/","",path),
                lat = NA,
                lon=NA) %>% 
  dplyr::filter(str_detect(path,"Quadrats"))


  for (i in 1:nrow(image_list)) {
    a <- exiftoolr::exif_read(image_list$path[i])
    
    lat_a <- a$GPSLatitude
    lon_B <- a$GPSLongitude
    
    image_list$lat[i] <- lat_a
    image_list$lon[i] <- lon_B
  } 
 
 if (!"Target_types" %in% colnames(image_list)) {
  image_list$Target_types <- NA
}

ui <- fluidPage(
  titlePanel("Image Annotation App"),
  sidebarLayout(
    sidebarPanel(
      uiOutput("category_ui"),
      textInput("new_category", "Add New Category"),
      actionButton("add_category_btn", "Add Category"),
      actionButton("next_btn", "Next Image")
    ),
    mainPanel(
      imageOutput("image_display", width = "900px")
    )
  )
)

server <- function(input, output, session) {
  # Reactive value to keep track of the current image index
  current_index <- reactiveVal(1)
  
  # ReactiveValues to store categories
  rv <- reactiveValues(categories = character())
  
  # Display the current image
  output$image_display <- renderImage({
    # Get the current image path
    img_path <- image_list$path[current_index()]
    
    # Check if the image file exists
    if (file.exists(img_path)) {
      list(src = img_path, contentType = 'image/jpeg', style = "width:100%; height:auto;", alt = "Image")
    } else {
      list(src = "https://via.placeholder.com/400x300?text=Image+Not+Found", contentType = 'image/png', alt = "Image Not Found")
    }
  }, deleteFile = FALSE)
  
  # Generate the UI for categories
  output$category_ui <- renderUI({
    if (length(rv$categories) > 0) {
      checkboxGroupInput("selected_categories", "Select Categories:", choices = rv$categories)
    } else {
      tags$p("No categories available. Please add a new category.")
    }
  })
  
  # Add new category
  observeEvent(input$add_category_btn, {
    new_cat <- input$new_category
    if (!is.null(new_cat) && new_cat != "") {
      rv$categories <- unique(c(rv$categories, new_cat))
      updateTextInput(session, "new_category", value = "")
    }
  })
  
  # Next button logic
  observeEvent(input$next_btn, {
    # Get selected categories
    selected_cats <- input$selected_categories
    if (is.null(selected_cats)) {
      selected_cats <- NA
    } else {
      selected_cats <- paste(selected_cats, collapse = ", ")
    }
    
    # Save the selected categories to 'Target_types' column
    image_list$Target_types[current_index()] <<- selected_cats
    
    # Move to next image
    if (current_index() < nrow(image_list)) {
      current_index(current_index() + 1)
      
      # Reset the selected categories input
      updateCheckboxGroupInput(session, "selected_categories", selected = character(0))
    } else {
      showModal(modalDialog(
        title = "End of Images",
        "You have reached the end of the images.",
        easyClose = TRUE
      ))
    }
  })
}

shinyApp(ui = ui, server = server)
 
write.csv(image_list, "Data/Biolittoral/Bio-Littoral_Drone/Quadrat_metadata.csv", row.names = F)


```

```{r img_list_text}
#| cache: true
#| echo: false
#| eval: true
#| warning: false

image_list <- read.csv("../Data/Biolittoral/Bio-Littoral_Drone/Quadrat_metadata.csv") %>% 
    as_tibble()

```

```{r Sites Quiberon}
#| cache: true
#| echo: false
#| eval: false
#| warning: false

library(tidyverse)
library(sf)
library(terra)
library(MapRs)
library(nngeo)
library(smoothr)
library(rnaturalearth) 
library(rnaturalearthdata) 

quadrat_sf <- image_list %>% 
  st_as_sf(coords = c("lon", "lat"), crs = 4326) %>% 
  mutate(Target_types = case_when(str_detect(Target_types,"Mix") ~ "Other",
                                  str_detect(Target_types,"Healthy") ~ "Healthy_seagrass",
                                  str_detect(Target_types,"Bleached") ~ "Bleached_seagrass",
                                  T ~ "Other")) %>% 
  dplyr::filter(Target_types %in% c("Bleached_seagrass","Healthy_seagrass"))# Assuming your data is in WGS84 (EPSG: 4326)


Drone_flight_area <- "Data/shp/Flight_area_drone.shp" %>% 
  read_sf()
######  Intertidal mask computing ######

lon_min <- -3.15
lon_max <- -3.07
lat_min <- 47.54
lat_max <- 47.6

poly <- data.frame(
  x = c(lon_min,lon_max,lon_max,lon_min),
  y = c(lat_max,lat_max,lat_min,lat_min),
  id = c(1,1,1,1)
)


# Ensure the polygon is closed by adding the first point at the end if necessary
if (!all(poly[1, c("x", "y")] == poly[nrow(poly), c("x", "y")])) {
  poly <- rbind(poly, poly[1, ])
}

# Create a matrix of coordinates
coords <- as.matrix(poly[, c("x", "y")])

# Create a list of coordinate matrices (required by st_polygon)
polygon_list <- list(coords)

# Create an 'sfc' (simple features geometry list column) object with the appropriate CRS
polygon_sfc <- st_sfc(st_polygon(polygon_list), crs = 4326) %>% 
  st_transform(32630)
  # CRS 4326 corresponds to WGS84

# Combine the 'id' with the geometry to create an 'sf' object
poly_sf <- st_sf(id = unique(poly$id), geometry = polygon_sfc)


Low_Tide <- "Data/Sentinel2/S2B_MSIL2A_20230903T110629_N0509_R137_T30TVT_20230903T125637.SAFE" %>% 
  list.files(pattern = ".jp2", recursive = T, full.names = T) %>% 
  as_tibble() %>% 
  rename(path = "value") %>% 
  dplyr::filter(str_detect(path, "10m"))

High_Tide <- "Data/Sentinel2/S2B_MSIL2A_20240503T112119_N0510_R037_T30TVT_20240503T130006.SAFE" %>% 
  list.files(pattern = ".jp2", recursive = T, full.names = T) %>% 
  as_tibble() %>% 
  rename(path = "value") %>% 
  dplyr::filter(str_detect(path, "10m"))

RGB_High <- rast(High_Tide$path[6]) %>% 
  crop(poly_sf)
RGB_Low <- rast(Low_Tide$path[6]) %>% 
  crop(poly_sf)

RGB(RGB_High) <- 1:3
RGB(RGB_Low) <- 1:3

NDVI_comp <- function(df,mask){
  
  B4 <- (rast(df$path[4])-1000) %>% 
    crop(mask)
  B8 <- (rast(df$path[5])-1000) %>% 
    crop(mask)
  
  ndvi = (B8-B4)/(B8+B4)
  return(ndvi)
}

 NDVI_High<- NDVI_comp(High_Tide,poly_sf)
 NDVI_Low<- NDVI_comp(Low_Tide,poly_sf)
 
 
int_mask <- NDVI_High < -0.05 & NDVI_Low > 0.05

values(int_mask)[values(int_mask) == F] <- NA

mask_sf <- as.polygons(int_mask) %>% 
  st_as_sf() %>% 
  st_cast("POLYGON") %>% 
  mutate(area = st_area(geometry)) %>% 
  dplyr::filter(as.numeric(area) > 6500) %>% 
  nngeo::st_remove_holes() %>% 
  smoothr::smooth(method = "ksmooth", smoothness = 3)
  
plot(mask_sf)


########## Geomgrob ##################"

sovereignty10 <- ne_countries(scale = 10, returnclass = "sf")

world_map <- sovereignty10 %>% 
  st_as_sf() %>% 
  dplyr::filter(sovereignt%in%c("Spain","France","Portugal",
                                "Italy","Andorra",
                                "United Kingdom",
                                "Switzerland","Belgium",
                                "Germany","Luxembourg") ) 

bbox_europe <- st_bbox(c(xmin = -20, ymin = 34,
                         xmax = 20, ymax = 55) ,
                       crs = st_crs(world_map) ) 

world_map<-st_make_valid(world_map) 

european_union_map_cropped <- st_crop(world_map, bbox_europe)  %>% 
  st_transform("+proj=laea +lat_0=52 +lon_0=10 +x_0=4321000 +y_0=3210000 +ellps=GRS80 +units=m +no_defs ")  


UnitedKingdom<-sovereignty10 %>% 
  st_as_sf() %>% 
  dplyr::filter(sovereignt%in%c("United Kingdom") ) %>% 
  st_cast("POLYGON") 

bbox_UK <- st_bbox(c(xmin = -20, ymin = 45,
                         xmax = 20, ymax = 55) ,
                       crs = st_crs(UnitedKingdom) ) 

UnitedKingdom<-st_make_valid(UnitedKingdom) 

UK_map_cropped <- st_crop(UnitedKingdom, bbox_UK)  %>% 
  st_transform("+proj=laea +lat_0=52 +lon_0=10 +x_0=4321000 +y_0=3210000 +ellps=GRS80 +units=m +no_defs ") 

Europe_sf<-european_union_map_cropped %>% 
  dplyr::bind_rows(UK_map_cropped) 

Miniworld_map <- sovereignty10 %>% 
  st_as_sf()

sf_use_s2(FALSE)

bbox_EU <- st_bbox(c(xmin = -30, ymin = 20,
                         xmax = 50, ymax = 70) ,
                       crs = st_crs(Miniworld_map) ) 

MiniEU_map<-st_crop(Miniworld_map, bbox_EU)  %>% 
  st_transform("+proj=laea +lat_0=52 +lon_0=10 +x_0=4321000 +y_0=3210000 +ellps=GRS80 +units=m +no_defs ")  


scaleFUN <- function(x) paste0(sprintf("%.2f", x),"°N")
  
Quiberon_Location <- data.frame(
  lon = mean(c(lon_max,lon_min)),
  lat = mean(c(lat_max,lat_min)),
  ID = "Quiberon",
  Site = " baie de Plouharnel"
) %>% 
  st_as_sf(coords=c("lon","lat") )  %>% 
  st_set_crs("EPSG:4326") %>% 
  st_transform("+proj=laea +lat_0=52 +lon_0=10 +x_0=4321000 +y_0=3210000 +ellps=GRS80 +units=m +no_defs ")  %>% 
  dplyr::mutate(lon = sf::st_coordinates(.) [,1],
                lat = sf::st_coordinates(.) [,2]) %>% 
  sf::st_set_geometry(NULL)


p1  <-
  ggplot(MiniEU_map) +
  geom_sf(linewidth=0.5,alpha=0.93,
          fill="#CFCFCF",colour="grey30")+
    ggforce::geom_mark_ellipse(data=Quiberon_Location,
                 aes(x=lon,
                     y=lat,
                     label = ID
                     # description=Site
                     ) ,
                 linewidth=0.2,
                 fill="goldenrod",
                 show.legend=F,
                 label.hjust = 0.3,
                 con.size = 1,
                 con.colour = "goldenrod4",
                 label.fontsize = c(12),
                 alpha=0.8,
                 expand = unit(1.5, "mm") , 
                 radius = unit(1.5, "mm") , 
                 label.buffer = unit(4, "mm") ,
                 label.fill = "grey90")+
  coord_sf(xlim=c(2600000,4100000) ,
          ylim=c(1600000,3100000))+
  theme_Bede_Map()+
  labs(x="Longitude",
       y="Latitude")+
  scale_y_continuous(labels=scaleFUN)+
  # theme(plot.margin = unit(c(0.0,0.0,0.0,0.0), "cm"),
  #       axis.title = element_blank(),
  #       axis.ticks = element_blank(),
  #       panel.grid.major = element_blank(),
  #       # axis.text.x = element_text(size = 20),
  #       # axis.text.y = element_text(size = 20) 
  #       axis.text.x = element_blank(),
  #       axis.text.y = element_blank() 
  #       )+
  theme_void()+
  theme(plot.background = element_rect(fill = "slategray3"))

col_sf <- c("Bleached_seagrass" = "darkred", 
            "Healthy_seagrass" = "darkgreen"
            # "Other" = "grey"
            )

# Extract x and y ranges
xlim <- c(lon_min, lon_max)
ylim <- c(lat_min, lat_max)

# Compute the coordinates for the rectangle (25% to 75% of the ranges)
xleft   <- xlim[1] + 0.745 * diff(xlim)
xright  <- xlim[1] + 0.99 * diff(xlim)
ybottom <- ylim[1] + 0.854 * diff(ylim)
ytop    <- ylim[1] + 0.975 * diff(ylim)

# Create a rectangle as an sf polygon
rectangle_coords <- matrix(c(
  xleft,  ybottom,
  xleft,  ytop,
  xright, ytop,
  xright, ybottom,
  xleft,  ybottom  # Close the polygon by repeating the first point
), ncol = 2, byrow = TRUE)

rectangle_sf <- st_polygon(list(rectangle_coords)) %>%
  st_sfc(crs = st_crs("EPSG:4326")) %>%
    st_transform("+proj=laea +lat_0=52 +lon_0=10 +x_0=4321000 +y_0=3210000 +ellps=GRS80 +units=m +no_defs ") %>%
  st_sf()


p2 <- ggplot() +
  tidyterra::geom_spatraster_rgb(data = RGB_Low) +
  geom_sf(data = mask_sf, aes(fill = "Mask"), color = "grey20", linewidth = 0.5) +
  geom_sf(data = Drone_flight_area, aes(fill = "Drone_Flight_Area"), color = "grey0", size = 2.2, linewidth = 0.5) +
  geom_sf(data = quadrat_sf, aes(color = Target_types), size = 2.1)+
  geom_sf(data = rectangle_sf, fill = "white", alpha = 0.5, color = NA) +
  scale_color_manual(
    values = col_sf,
    labels = c("Blackened seagrasses", "Healthy seagrasses", "Other"),
    name = NULL
  ) +
  scale_fill_manual(
    values = c("Mask" = "grey90", "Drone_Flight_Area" = "grey70"),
    labels = c("Drone Flight", "Intertidal area"),
    name = NULL  # No title for the fill legend
  ) +
  coord_sf(expand = F) +
  theme_Bede_Map() +
  guides(
    fill = guide_legend(order = 2),  # Order the fill legend
    color = guide_legend(order = 1)  # Order the color legend
  ) +
  labs(fill = NULL, colour = NULL)+
  theme(
    legend.background = element_rect(fill = alpha("white", 0)),
    legend.box = "vertical",  # Stack legends vertically
    legend.box.just = "left",  # Align the legends to the left
    legend.spacing.y = unit(0.0, 'mm'),  # Adjust the spacing between items
    legend.key = element_rect(fill = "white", color = "black"),  # Ensure clear legend keys
    legend.box.margin = margin(5, 5, 5, 5)
    )  # Adjust position if needed  )

# p2

combined_plot <- ggdraw() +
  draw_plot(p2) +                    # Main plot
  draw_plot(p1, x = 0.65, y = 0.05,   # p1 inset (bottom right)
            width = 0.3, height = 0.3)

ggsave("Paper/Figs/Quiberon_map.png", combined_plot, width = 10, height = 10, dpi = 800)

```

```{r Fig Site Quiberon Plot}
#| cache: false
#| echo: false
#| warning: false
#| fig-cap: Location of the fieldtrip campaign that occured in the 10th of September 2021. The light grey polygons indicates the intertidal zone (Zone between High tide and low tide, that is totally emerged at low tide) and the dark grey polygon indicate the extent of the drone flight. Green dots indicate location of quadrat picture over healthy seagrasses while red dots indicate location of quadrat took over darkened seagrasses. 
#| label: fig-quiberonMap
#| fig-width: 10
#| fig-height: 10
#| out-width: "100%"

knitr::include_graphics("Figs/Quiberon_map.png")
```

A fieldtrip, aiming to map a seagrass meadow near Quiberon (France : 46°57'32.0"N, 2°10'37.0"W), occurred in the 10th of September 2021 [@fig-quiberonMap]. During this fieldtrip, darkening of seagrasses have been observed, resulting in the darkening of seagrass leaves over large area of the meadow [@fig-QuiberonImg C & D]. During this field trip, drone flights were conducted over two areas of the seagrass meadow using a DJI Matrice 200 equipped with a Sequoia Multispectral camera. The Sequoia captures four spectral bands: Green (550 ± 40 nm), Red (660 ± 40 nm), RedEdge (735 ± 10 nm), and Near Infrared (790 ± 40 nm). A total of `r nrow(image_list)` Ground Control Points (GCPs) were collected in the form of georeferenced quadrat images across the meadow . These images allow for visual assessment of vegetation type, density, and health status. The images were then divided into two categories: Healthy seagrasses and darkened seagrasses, based on a visual estimation of the leaf condition [@fig-quiberonMap].

```{r img_Quiberon}
#| cache: true
#| echo: false
#| eval: false
#| warning: false

library(tidyverse)
library(tidyterra)
library(terra)

get_letter_position <- function(img){
  
  ext <- ext(img)
  
  x <- as.numeric(ext[1]+(0.05*(ext[2]-ext[1])))
  y <- as.numeric(ext[3]+(0.95*(ext[4]-ext[3])))

  
  return(c(ext[1]+0.1, ext[4]-0.1))
}



A <- rast("Data/imgs/biolittoral/healthy_landscap.png") 
ext(A) <- c(0,1,-2.05,0)

B <- rast("Data/imgs/biolittoral/Quadrat_Healthy.png") 
ext(B) <- c(1.05,2.05,-1,0)

C <- rast("Data/imgs/biolittoral/Quadrat_darkened.png")
ext(C) <- c(1.05,2.05,-2.05,-1.05)

D <- rast("Data/imgs/biolittoral/darkened_landscap.png") 
ext(D) <- c(2.1,3.1,-2.05,0)


letter_A <- get_letter_position(A)
letter_B <- get_letter_position(B)
letter_C <- get_letter_position(C)
letter_D <- get_letter_position(D)

letter_size <- 3

plot <- ggplot()+
  geom_spatraster_rgb(data = A, maxcell = 20e+05)+
  geom_spatraster_rgb(data = B, maxcell = 20e+05)+
  geom_spatraster_rgb(data = C, maxcell = 20e+05)+
  geom_spatraster_rgb(data = D, maxcell = 20e+05)+
  coord_equal()+
  geom_label(aes(x = letter_A[1],y=letter_A[2], label = "A"), alpha = 0.5, size = letter_size)+
  geom_label(aes(x = letter_B[1],y=letter_B[2], label = "B"), alpha = 0.5, size = letter_size)+
  geom_label(aes(x = letter_C[1],y=letter_C[2], label = "C"), alpha = 0.5, size = letter_size)+
  geom_label(aes(x = letter_D[1],y=letter_D[2], label = "D"), alpha = 0.5, size = letter_size)+
  theme_void()+
  theme(axis.text = element_blank(), 
        axis.title = element_blank(), 
        axis.ticks = element_blank(), 
        axis.ticks.length = unit(0, "pt"),
        panel.grid.major=element_blank(), 
        panel.grid.minor=element_blank(), 
        plot.margin = margin(0, 0, 0, 0, "pt"))

ggsave("Paper/Figs/img_Quiberon.png",plot, width = 3.1, height = 2.05, dpi = 800)

```

```{r Fig img_Quiberon}
#| cache: false
#| echo: false
#| warning: false
#| fig-cap: "Illustrations of the two health conditions of seagrasses observed in the field. A: Global view of a healthy green meadow; B: Quadrat images of healthy seagrasses; C: Quadrat images of darkened seagrasses; D: Global view of an unhealthy darkened meadow. All images were taken on September 10th, 2021, in Quiberon."
#| label: fig-QuiberonImg
#| fig-width: 10
#| fig-height: 10
#| out-width: "100%"

knitr::include_graphics("Figs/img_Quiberon.png")
```

### Air temperature

Since January 1, 2024, Meteo France weather data has been freely and openly accessible. Hourly air temperature data (°C) for the French Atlantic and Channel coasts was retrieved using a [custom script](https://github.com/SigOiry/HeatWave_Seagrasses/blob/main/Scripts/MeteoFrance_Extraction.qmd) as no API was available at the time of this study. Weather stations located within 10 kilometers of the coastline were considered, but only those with at least 30 years of data were included to ensure reliable climatological reconstruction. Of the 156 weather stations within 10 kilometers of the coast, only 36 had sufficient data for climatology reconstruction. The hourly data was then aggregated into daily mean temperatures for each station.

Heatwave detection was performed using the HeatwaveR package in R [@heatwaveR]. This package utilizes the methodology proposed by @hobday2016hierarchical to detect heatwave events. The climatology for the year was computed using the temperature time series. An event was considered a heatwave each time the temperature exceeded the 90th percentile of the climatology for three consecutive days. The severity of each event has been assessed using the methodology proposed by @hobday2018categorizing.

### Water temperature

```{r Polygon_area_SST}
#| cache: true
#| echo: false
#| eval: true
#| warning: false

library(sf)
# Define the bounding box around Quiberon (adjust the range as needed)
lon_min <- -3.5
lon_max <- -2.7
lat_min <- 47.3
lat_max <- 47.7

poly <- data.frame(
  x = c(lon_min,lon_max,lon_max,lon_min),
  y = c(lat_max,lat_max,lat_min,lat_min),
  id = c(1,1,1,1)
)


# Ensure the polygon is closed by adding the first point at the end if necessary
if (!all(poly[1, c("x", "y")] == poly[nrow(poly), c("x", "y")])) {
  poly <- rbind(poly, poly[1, ])
}

# Create a matrix of coordinates
coords <- as.matrix(poly[, c("x", "y")])

# Create a list of coordinate matrices (required by st_polygon)
polygon_list <- list(coords)

# Create an 'sfc' (simple features geometry list column) object with the appropriate CRS
polygon_sfc <- st_sfc(st_polygon(polygon_list), crs = 4326)  # CRS 4326 corresponds to WGS84

# Combine the 'id' with the geometry to create an 'sf' object
poly_sf <- st_sf(id = unique(poly$id), geometry = polygon_sfc)

poly_sf_projected <- st_transform(poly_sf, crs = 32630)  # UTM Zone 30N

# 2. Calculate the area in square meters
area_poly_sst_m2 <- st_area(poly_sf_projected)

# 3. Convert the area to square kilometers
area_poly_sst_km2 <- units::set_units(area_poly_sst_m2, km^2)

# Convert the units object to numeric for rounding
area_poly_sst_numeric <- as.numeric(area_poly_sst_km2)

# 4. Round the area to the nearest hundred
area_poly_sst_rounded <- round(area_poly_sst_numeric / 100) * 100
```

Sea Surface Temperature (SST) data were downloaded from the Copernicus CMEMS platform [@CMEMS_1] for the French coast, covering the period from 1982 to 2022. Only pixels within an area of `r area_poly_sst_rounded` km² around Quiberon, Brittany, France (47°29′03″N, 3°07′09″W) were extracted and analyzed. This area was large enough to minimize missing values caused by cloud cover, yet small enough to avoid being influenced by the stability of offshore SST. After the masking step, a daily average of the remaining pixels was calculated, resulting in a daily mean SST value for the entire time series. Using this daily average since 1982, the SST climatology was computed with the HeatwaveR package in R [@heatwaveR]. The same methodology used to detect air temperature events was applied to identify SST events.

## Experiment

### Sampling and acclimation of seagrasses

Seagrass was sampled from a *Nanozostera noltei* (dwarf eelgrass, syn. *Zostera noltei*) meadow on Noirmoutier Island, France (46°57'32.0"N, 2°10'37.0"W) at low tide in June 2024. A home-made inox sampling box was used to sample seagrass from an area of 30 cm by 15 cm and 5 cm deep, maintaining the sediment structure and avoiding damage to the rhizomes and the leafs of the seagrass (@fig-design A). This sampling box allowed to limitate sampling variability between replicates. The seagrass, along with sediment, meiofauna, and macrofauna, was placed in plastic trays. To avoid hydric stress during transportation, seawater was added to each tray. Simultaneously, seawater was sampled from a nearby site and transported to the lab, where it was filtered using a 0.22 µm nitrocellulose filter to remove all suspended particulate matter. This seawater was used in the acclimation tank and the intertidal chambers. The seagrasses were acclimated at high tide for one weeks with a water temperature of 17°C, matching the temperature at the time of sampling, and with light of 150 µmol.s-1.m-2 of PAR photons [@akbar2020mangrove]. A wave generator was used in the tank to circulate and reoxygenate the water.

### Experimental design

```{r pictures design}
#| cache: true
#| echo: false
#| eval: false
#| warning: false

library(tidyverse)
library(tidyterra)
library(terra)

get_letter_position <- function(img){
  
  ext <- ext(img)
  
  x <- as.numeric(ext[1]+(0.05*(ext[2]-ext[1])))
  y <- as.numeric(ext[3]+(0.95*(ext[4]-ext[3])))

  
  return(c(ext[1]+0.1, ext[4]-0.1))
}



A <- rast("Data/imgs/Simon_Sampling.png") 
ext(A) <- c(0,0.975,-1.95,0)

B <- rast("Data/imgs/Chamber.jpg") 
ext(B) <- c(1.025,2,-1.95,0)

D <- rast("Data/imgs/Seagrass_before_zoomed.png")
ext(D) <- c(2.05,3.025,-1.4625,0)

C <- rast("Data/imgs/Tray_high.jpg") 
ext(C) <- c(0,2,-2.975,-2)

E <- rast("Data/imgs/Seagrass_after_zoomed.png")
ext(E) <- c(2.05,3.025,-2.975,-1.5125)

letter_A <- get_letter_position(A)
letter_B <- get_letter_position(B)
letter_C <- get_letter_position(C)
letter_D <- get_letter_position(D)
letter_E <- get_letter_position(E)

letter_size <- 3

plot <- ggplot()+
  geom_spatraster_rgb(data = A, maxcell = 20e+05)+
  geom_spatraster_rgb(data = B, maxcell = 20e+05)+
  geom_spatraster_rgb(data = C, maxcell = 20e+05)+
  geom_spatraster_rgb(data = D, maxcell = 20e+05)+
  geom_spatraster_rgb(data = E, maxcell = 20e+05)+
  coord_equal()+
  geom_label(aes(x = letter_A[1],y=letter_A[2], label = "A"), alpha = 0.5, size = letter_size)+
  geom_label(aes(x = letter_B[1],y=letter_B[2], label = "B"), alpha = 0.5, size = letter_size)+
  geom_label(aes(x = letter_C[1],y=letter_C[2], label = "C"), alpha = 0.5, size = letter_size)+
  geom_label(aes(x = letter_D[1],y=letter_D[2], label = "D"), alpha = 0.5, size = letter_size)+
  geom_label(aes(x = letter_E[1],y=letter_E[2], label = "E"), alpha = 0.5, size = letter_size)+
  theme_void()+
  theme(axis.text = element_blank(), 
        axis.title = element_blank(), 
        axis.ticks = element_blank(), 
        axis.ticks.length = unit(0, "pt"),
        panel.grid.major=element_blank(), 
        panel.grid.minor=element_blank(), 
        plot.margin = margin(0, 0, 0, 0, "pt"))

ggsave("Paper/Figs/Experimental_design.png",plot, width = 3.025, height = 2.975, dpi = 800)

```

```{r Fig design}
#| cache: false
#| echo: false
#| warning: false
#| fig-cap: "Illustrations of the various steps of the experiment. A: Field sampling of seagrass using a homemade sampling box; B: Intertidal chambers used during the experiment; C: Seagrass sample inside a chamber during the experiment at high tide; D: Photo of the treatment sample at the start of the experiment; E: Photo of the treatment sample at the end of the experiment."
#| label: fig-design
#| fig-width: 10
#| fig-height: 10
#| out-width: "100%"

knitr::include_graphics("Figs/Experimental_design.png")
```

Two intertidal chambers from [ElectricBlue](https://electricblue.eu/intertidal-chamber) were used to simulate tidal cycles and control water temperature during high tide and air temperature during low tide (@fig-design B,C). One chamber served as the control, while the other was used for the experimental treatment. The control chamber was maintained at temperatures representative of the typical seasonal conditions: water temperatures between 18°C and 19°C and air temperatures between 18°C and 23°C, following circadian temperature variability (@fig-Profile left). For the experimental treatment, the air temperature was set to mimic an atmospheric heatwave that occurred over the seagrass meadow of Porh Saint-Guénël, Plouharnel, France (47°35'40.0"N, 3°07'30.0"W) from August 26, 2021, to September 6, 2021. On the first day of the experiment, air temperatures in the experimental chamber were set to range from 23°C at night to 35°C during the day, with a daily increase of 1°C. The water temperature in the experimental chamber was similarly adjusted to reflect the heatwave conditions, starting from the normal seasonal range (18°C) and gradually increasing to simulate the rising temperatures experienced during the heatwave (+0.5°C daily). This setup aimed to replicate the thermal stress experienced by the seagrass meadow during the actual heatwave event (@fig-Profile right).

```{r chamber profiles}
#| cache: true
#| echo: false
#| eval: false
#| warning: false

library(MapRs)
library(tidyverse)
library(Utilities.Package)
library(patchwork)

experimental_design <- Make_Chamber_Profile(min_Air_Temp_control = 19,
                                            max_Air_Temp_control = 23,
                                            min_Air_Temp_test = 23,
                                            max_Air_Temp_test = 35,
                                            min_Water_Temp_control= 18, 
                                            max_Water_Temp_control = 18,
                                            min_Water_Temp_test = 18,
                                            max_Water_Temp_test = 18,
                                            date_start = "2024-07-22 21:00:00",
                                            date_end = "2024-07-26 23:00:00",
                                            low_tide_time = "2024-07-23 12:00:00",
                                            High_Tide_Until = "2024-07-24 09:00:00",
                                            daily_increase_Air_Test = 1,
                                            daily_increase_Water_Test = 0.5,
                                            daily_increase_Air_Control = 0,
                                            daily_increase_Water_Control = 0,
                                            sunrise = 6.25,
                                            sunset = 22,
                                            max_light_intensity = 120,
                                            export_profile = F,
                                            Tide = "both",
                                            night_tide = T,
                                            time_step = 60, 
                                            Save_Experiment = F, 
                                            Experiment_Name = "HW5_24072024_to_26072024")

df_control <- experimental_design$Control_df %>% 
  dplyr::filter(Time > as.POSIXct("2024-07-24 00:00:00", format = "%Y-%m-%d %H:%M", tz = "UTC")) %>% 
  dplyr::mutate(scenario = "Control")
df_test <- experimental_design$Test_df %>% 
  dplyr::filter(Time > as.POSIXct("2024-07-24 00:00:00", format = "%Y-%m-%d %H:%M", tz = "UTC")) %>% 
  dplyr::mutate(scenario = "Test")

df <- df_control %>% 
  bind_rows(df_test)

polygon_table <-   df %>% 
  group_by(tide_ID) %>% 
  reframe(Tide_Status = unique(Tide_Status), 
          xmin = min(Time),
          xmax = max(Time),
          T_min = min(Temp_Air,Temp_Water),
          T_max = max(Temp_Air,Temp_Water)) %>% 
  ungroup() %>% 
  mutate( ymin = min(T_min),
          ymax = max(T_max)) %>% 
  rename(Tide = Tide_Status) %>% 
  mutate(Tide = case_when(Tide == "High_Tide" ~ "High Tide",
                          TRUE ~ "Low Tide"))

#### Test
water_polyline_test <- df %>% 
  dplyr::filter(scenario == "Test") %>% 
  dplyr::filter(Tide_Status == "High_Tide") 

air_polyline_test <- df %>% 
  dplyr::filter(scenario == "Test") %>% 
  dplyr::filter(Tide_Status == "Low_Tide")

max_air_temp_test <- df %>% 
  dplyr::filter(scenario == "Test") %>% 
  dplyr::filter(Tide_Status == "Low_Tide") %>% 
  group_by(tide_ID) %>% 
  dplyr::filter(Temp == max(Temp)) %>% 
  dplyr::filter(Temp >=35)

  cols_fill <- c("High Tide" = "gray1", "Low Tide" = "gray50")
  cols_col <- c("Air Temperature" = "red4", "Water Temperature" = "blue3")



plot_treatment <- df %>% 
  dplyr::filter(scenario == "Test") %>% 
ggplot()+
  geom_line(aes(x = Time, y = Temp))+
  geom_rect(data = polygon_table , aes(ymin = 18, ymax = 39, xmin = xmin, xmax =xmax, fill = Tide, group = tide_ID),alpha = 0.1,show.legend = F) +
  geom_line(data = df  %>% 
    dplyr::filter(Time > as.POSIXct("2024-07-24 09:00:00", format = "%Y-%m-%d %H:%M", tz = "UTC")) %>% 
    dplyr::filter(scenario == "Test"),
    aes(x = Time, y = Temp_Water, color = "Water Temperature"), linewidth = 1, linetype = "dashed", alpha = 0.3,show.legend = F)+
  geom_line(data = water_polyline_test, aes(x = Time, y = Temp, group = tide_ID, color = "Water Temperature"), linewidth = 1,show.legend = F)+
    scale_x_datetime(date_breaks = "6 hour", date_labels = "%H:%M") +
  geom_line(aes(x = Time, y = Temp_Air, color = "Air Temperature"), linewidth = 1, linetype = "dashed", alpha = 0.3,show.legend = F)+
  geom_line(data = air_polyline_test, aes(x = Time, y = Temp, group = tide_ID, color = "Air Temperature"),, linewidth = 1,show.legend = F)+
    geom_text(data = data.frame(x = as.POSIXct("2024-07-24 03:00:00", format = "%Y-%m-%d %H:%M", tz = "UTC"), y = 38.5, label = "Treatment"), aes( x = x, y =y , label = label), hjust = 0, size = 10)+
    scale_fill_manual(name = "legend",
                      values = cols_fill) +
    scale_color_manual(name = "legend",
                       values = cols_col) +
   ggforce::geom_mark_ellipse(data=max_air_temp_test,
                 aes(x=Time,
                     y=Temp,
                     x0 = Time, 
                     y0 = Temp + 1,
                     label = paste0(Temp, " °C"),
                     group = tide_ID),
                     # description=Description),
                 size=0.3,
                 fill = "goldenrod",
                 con.colour = "goldenrod4",
                 show.legend=F,
                 label.fontsize = 25,
                 label.hjust = 0.5,
                 con.size = 2,
                 alpha=0.8,
  expand = unit(2, "mm") , 
  radius = unit(2, "mm") ,
  label.fill = NA,
  label.buffer = unit(5, "mm"))+
  ylab("Temperature (°C)")+
  ylim(c(18,39))+
  scale_y_continuous(position = "right") +
  theme_Bede()+
    theme(axis.text.x = element_text(size = 25, angle = 45, vjust = 0.6),
          axis.text.y = element_text(size = 25),
          axis.title.x = element_text(size = 30),
          axis.title.y = element_text(size = 30))

### Control 
water_polyline_control <- df %>% 
  dplyr::filter(scenario == "Control") %>% 
  dplyr::filter(Tide_Status == "High_Tide") 

air_polylines_control <- df %>% 
  dplyr::filter(scenario == "Control") %>% 
  dplyr::filter(Tide_Status == "Low_Tide")

max_air_temp_control <- df %>% 
  dplyr::filter(scenario == "Control") %>% 
  dplyr::filter(Tide_Status == "Low_Tide") %>% 
  group_by(tide_ID) %>% 
  dplyr::filter(Temp == max(Temp)) %>% 
  dplyr::filter(Temp >=20)

  # cols_fill <- c("High Tide" = "gray30", "Low Tide" = "gray90")
  # cols_col <- c("Air Temperature" = "red4", "Water Temperature" = "blue3")




plot_control <- df %>% 
  dplyr::filter(scenario == "Control") %>% 
  ggplot()+
    geom_line(aes(x = Time, y = Temp),alpha = 0.2, linewidth = 1)+
    geom_rect(data = polygon_table , aes(ymin = 18, ymax = 39, xmin = xmin, xmax =xmax, fill = Tide, group = tide_ID),alpha = 0.1) +
    geom_line(data = df  %>% 
      dplyr::filter(Time > as.POSIXct("2024-07-24 09:00:00", format = "%Y-%m-%d %H:%M", tz = "UTC")) %>% 
      dplyr::filter(scenario == "Control"),
      aes(x = Time, y = Temp_Water, color = "Water Temperature"), linewidth = 1, linetype = "dashed", alpha = 0.3)+
    geom_line(data = water_polyline_control, aes(x = Time, y = Temp, group = tide_ID, color = "Water Temperature"), linewidth = 1)+
    scale_x_datetime(date_breaks = "6 hour", date_labels = "%H:%M") +
    geom_line(aes(x = Time, y = Temp_Air, color = "Air Temperature"), linewidth = 1, linetype = "dashed", alpha = 0.3)+
    geom_line(data = air_polylines_control, aes(x = Time, y = Temp, group = tide_ID, color = "Air Temperature"), linewidth = 1)+
    geom_text(data = data.frame(x = as.POSIXct("2024-07-24 03:00:00", format = "%Y-%m-%d %H:%M", tz = "UTC"), y = 38.5, label = "Control"), aes( x = x, y =y , label = label), hjust = 0,size = 10)+
    ggforce::geom_mark_ellipse(data=max_air_temp_control,
                   aes(x=Time,
                       y=round(Temp,0),
                       x0 = Time, 
                       y0 = Temp + 1,
                       label = paste0(round(Temp,0), " °C"),
                       group = tide_ID),
                       # description=Description),
                   size=0.3,
                   fill = "goldenrod",
                   con.colour = "goldenrod4",
                   show.legend=F,
                   label.fontsize = 25,
                   label.hjust = 0.5,
                   con.size = 2,
                   alpha=0.8,
    expand = unit(2, "mm") , 
    radius = unit(2, "mm") ,
    label.fill = NA,
    label.buffer = unit(5, "mm"))+
    scale_fill_manual(name = "legend",
                      values = cols_fill) +
    scale_color_manual(name = "legend",
                       values = cols_col) +
  ylab("Temperature (°C)")+

    ylim(c(18,39))+
    theme_Bede()+
    theme(legend.position = c(0.16,.8),
          legend.background = element_rect(fill=scales::alpha('white', 0.8)),
          legend.text = element_text(size = 20, hjust = 0),
          legend.title = element_blank(),
          legend.key.size = unit(0.7,"cm"),
          legend.spacing = unit(0,"mm"),
          axis.text.x = element_text(size = 25,angle = 45, vjust = 0.6),
          axis.text.y = element_text(size = 25),
          axis.title.x = element_text(size = 30),
          axis.title.y = element_text(size = 30))


plt <- plot_control + plot_treatment

ggsave("Paper/Figs/Chamber_Profils.png",plt, height = 874*4, width = 1911*4, unit= "px")
```

```{r Fig Profiles}
#| cache: false
#| echo: false
#| warning: false
#| fig-cap: "Temperature profiles of both the control (left) and the treatment (right) followed during the heatwave experiment. The red line indicates air temperature, whereas the blue line indicates water temperature. Due to the tidal cycle followed during the experiment, the seagrasses only experience temperatures representade by solid lines."
#| label: fig-Profile
#| fig-width: 10
#| fig-height: 8
#| out-width: "100%"

knitr::include_graphics("Figs/Chamber_Profils.png")
```

### Measurement and sampling

#### Hyperspectral measurement

Throughout the experiment, hyperspectral signatures of both the control and treatment seagrasses were taken using an ASD HandHeld 2 equipped with a fiber optic, allowing measurements to be taken directly inside the chamber without opening it. Automatic spectra acquisition has been done using the [RS3 softaware](https://www.malvernpanalytical.com/en/learn/knowledge-center/user-manuals/rs3-software-user-manual) developed by the intrument manufacturer. An average of five reflectance spectrum ($R(\lambda)$), each with an integration time of 544 ms, was taken every minute. Every 10 minutes, the fiber optic was switched from one benthic chamber to the other, in order to measure reflectance in both treatment and control. Because light conditions were controlled inside of the chambers, reflectance calibration of the instrument was performed only each morning at the very first moment of low tide using a Spectralon white reference with 99% Lambertian reflectivity.

The second derivative of $R$ was calculated to retrieve absorption features and compare their variability over time. Two radiometric indices were also monitored throughout the experiment :

-   The Normalized Difference Vegetation Index (NDVI, @rouse1974monitoring), as a proxy of the concentration of chlorophyll-a (@eq-ndvi)

$$
NDVI = \frac{R(840)-R(668)}{R(840)+R(668)}
$$ {#eq-ndvi}

where $R(840)$ and $R(668)$ are the reflectance at 840 nm and 668 nm respectively.

-   The Green Leaf Index (GLI, @louhaichi2001spatially), as a measurement of the greenness of seagrass leafs (@eq-gli)

$$
GLI = \frac{[R(550)-R(668)]+[R(550)-R(450)]}{(2 \times R(550) )+ R(668) + R(450) }
$$ {#eq-gli}

where $R(550)$ and $R(450)$ are the reflectance in green at 550 nm and in the blue at 450 nm, respectively.

-   The Mid-Infrared Water Absorption Index (MIWAI), proposed here and designed to measure water absorption at 970 nm (**REF**), estimates the difference between the reflectance at 970 nm and a linear interpolation of the reflectance values at 950 and 990 nm. This interpolation represents the expected reflectance value in the absence of water.

$$
MIWAI = 0.5 \times [R(990)+R(950)]-R(970)
$$ {#eq-MIWAI}

where $R(990)$, $R(970)$ and $R(950)$ are the reflectance in the infrared at 990, 970 and 950 nm, respectively.

> #### Multispectral imagery measurement
>
> Parallel to hyperspectral measurements, multispectral images were taken at the beginning and end of each diurnal low tide (09:00 am and 03:00 pm). A Micasense RedEdge-MX Dual multispectral camera, originally designed to be mounted on a drone, was modified for use without a drone. A 3D-printed mount was designed to attach the camera to the intertidal chamber and ensure that each picture was captured under the same conditions. At each time step (09:00 am and 03:00 pm), a first picture of the Spectralon was taken to allow for image correction in reflectance, followed by a second picture of the target. [DISCOV](https://sigoiry.github.io/DISCOV-MicaSense/), a Neural Network classification model previously developed to map intertidal vegetation using drone imagery, has been applied to each image taken inside the intertidal chambers. To understand the behavior of the model on seagrasses affected by heatwaves, classification images from before and after the heatwave have been compared.

#### Leaves sampling and HPLC measurement

At the beginning and the end of each diurn low tide (09:00 am and 03:00 pm) leaves samples have been took in both the test and the control. leaves sampled have been stored under -80°C waiting for analysis. Pigment composition and biomass were analyzed using high-performance liquid chromatography (HPLC). The HPLC system (Alliance HPLC 248 System, Waters) was equipped with a reverse-phase C-18 separating column (SunFire C-18 Column, 100Å, 3.5 µm, 2.1 mm x 50 mm, Waters), preceded by a precolumn (VanGuard 3.9 mm x 5 mm, Waters). The system also included a photodiode array detector (2998 PDA) and a fluorimeter (Ex: 425 nm, Em: 655 nm; RF-20A, SHIMADZU).

**Au secours Philippe !!!**

# Results

```{r SST_processing}
#| cache: true
#| echo: false
#| eval: false
#| warning: false

library(tidyverse)
library(terra)
library(ncdf4)
library(heatwaveR)
library(Utilities.Package)
library(reshape2)



######### NC PLOTTING ################


file_path <- "Data/SST/cmems_obs-sst_atl_phy_my_l3s_P1D-m_1729089512246.nc"
nc <- nc_open(file_path)

# Get the temperature variable (adjust the variable name if different)
temp_var_name <- "adjusted_sea_surface_temperature"
temperature_data <- ncvar_get(nc, temp_var_name)

# Get the longitude and latitude variables (adjust variable names if different)
lon <- ncvar_get(nc, "longitude")
lat <- ncvar_get(nc, "latitude")

# Compute the mean SST over time at each grid point
mean_sst_map <- apply(temperature_data, c(1, 2), sd, na.rm = TRUE)

# Convert the 2D array to a data frame for plotting
mean_sst_df <- melt(mean_sst_map, varnames = c("lon_idx", "lat_idx"), value.name = "mean_sst")
mean_sst_df$lon <- lon[mean_sst_df$lon_idx]
mean_sst_df$lat <- lat[mean_sst_df$lat_idx]

# Convert Kelvin to Celsius if necessary
mean_sst_df$mean_sst_celsius <- mean_sst_df$mean_sst - 273.15



# Plot the mean SST map
ggplot() +
  geom_tile(data = mean_sst_df,  mapping = aes(x = lon, y = lat, fill = mean_sst_celsius)) +
  geom_polygon(data = poly, mapping = aes(x = x, y = y, group = id), alpha = 0.8)+
  scale_fill_viridis_c(option = "inferno") +
  coord_fixed() +
  labs(title = "Mean Sea Surface Temperature", fill = "Temperature (°C)") +
  theme_minimal()


##### NC opening and processing ######

file_path <- "Data/SST/cmems_obs-sst_atl_phy_my_l3s_P1D-m_1729089512246.nc"

# Open the NetCDF file
nc <- nc_open(file_path)

# Get the temperature variable (adjust the variable name if different)
temp_var_name <- "adjusted_sea_surface_temperature"
temperature_data <- ncvar_get(nc, temp_var_name)

# Get the time variable
time_data <- ncvar_get(nc, "time")  # Adjust "time" if the name is different

# Get the longitude and latitude variables
lon <- ncvar_get(nc, "longitude")  # Adjust "longitude" if the name is different
lat <- ncvar_get(nc, "latitude")   # Adjust "latitude" if the name is different



# Adjust longitudes if they are in the range [0, 360]
if (max(lon) > 180) {
  lon <- ifelse(lon > 180, lon - 360, lon)
}

# Find the indices of lon and lat within the bounding box
lon_indices <- which(lon >= lon_min & lon <= lon_max)
lat_indices <- which(lat >= lat_min & lat <= lat_max)

# Subset the temperature data
temperature_data_subset <- temperature_data[lon_indices, lat_indices, ]

# Calculate the mean temperature over the spatial dimensions for each time point
mean_temperature <- apply(temperature_data_subset, 3, mean, na.rm = TRUE)

# Convert time data to POSIXct format (adjust the origin if necessary)
sst <- data.frame(time = time_data, sst = mean_temperature) %>%
  mutate(time = as.POSIXct(time, origin = "1970-01-01"))

# Plot the SST over time
sst %>%
  filter(!is.na(sst)) %>%
  ggplot(aes(x = time, y = sst - 273.15)) +
  geom_point(alpha = 0.3) +
  geom_smooth(method = "glm") +
  labs(x = "Time", y = "SST (°C)", title = "Mean SST around Quiberon Over Time")


#### HEATWAVE DETECTION ########

df_heatwaveR <- sst %>% 
  rename(t = time,
         temp = sst) %>%
  mutate(t = as.Date(t),
         temp = temp - 273.15) %>% 
  dplyr::select(t,temp) 

  
  df_heatwaveR[which(df_heatwaveR$t == as.Date("2021-09-07")),]$temp = df_heatwaveR[which(df_heatwaveR$t == as.Date("2021-09-07")),]$temp +0.8 

  clim <- ts2clm(df_heatwaveR, climatologyPeriod = c(min(df_heatwaveR$t), max(df_heatwaveR$t)))
  
  event <- detect_event(clim,categories = T,minDuration = 3)
  res <- detect_event(clim, minDuration = 3)
  mhw <- res$clim

  mhw_filled <- mhw %>%
  arrange(t) %>%
  mutate(
    # Replace NaN with NA for compatibility
    temp = ifelse(is.nan(temp), NA, temp),
    missing = case_when(is.na(temp) ~ T,
                        T ~ F),
    # Convert Date to numeric if it's not already
    Date_num = as.numeric(t),
    # Perform linear interpolation
    temp = approx(
      x = Date_num[!is.na(temp)],
      y = temp[!is.na(temp)],
      xout = Date_num,
      method = "linear",
      rule = 2
    )$y
  ) %>%
  select(-Date_num) 
  
  mhw_segments <- mhw_filled %>%
  mutate(
    t_lead = lead(t),
    temp_lead = lead(temp),
    missing_lead = lead(missing)
  ) %>%
  filter(!is.na(t_lead)) %>%
  mutate(
    # Determine linetype based on missingness of adjacent points
    linetype = ifelse(missing & missing_lead, "solid", "dashed")
  )
  
mhw_segments %>%
  filter(t > as.Date("2021-07-15") & t < as.Date("2021-10-15")) %>%
  ggplot() +
  # Draw line segments with varying linetypes
  geom_segment(aes(x = t, y = temp, xend = t_lead, yend = temp_lead, linetype = linetype), show.legend = F) +
  # Add the flame and threshold lines if 'thresh' is available
  geom_flame(aes(x = t, y = temp, y2 = thresh),fill = "darkblue", alpha = 0.8) +
  geom_line(aes(x = t, y = thresh, color = "P90")) +
  theme_Bede()
```

# Bibliography
